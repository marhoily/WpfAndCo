<#@ template language="C#" #>
<#@ import namespace="System.Linq" #>
using System.ComponentModel.DataAnnotations;
using System.Linq;
using Generator;

namespace Sample.Generated {
    [IoC]
    public sealed class Delete<#=_type.Name#>Validator : IValidator<Delete<#=_type.Name#>Command>
    {
<#
		//    ________
		//___/ Fields \________________________________________
    foreach (var t in _type.AggregatorRequiredByDelete)
    {
#>
		private readonly <#=t.Name#>Aggregate <#=t.Name.AsField()#>Aggregate;
<#
    }
#>
<#
		//    _____________
		//___/ Constructor \___________________________________
#>
		public Delete<#=_type.Name#>Validator(<#=
			_type.AggregatorRequiredByDelete.Join(
				t => $"{t.Name}Aggregate {t.Name.AsLocal()}Aggregate")#>)
		{
<#
    foreach (var t in _type.AggregatorRequiredByDelete)
    {
#>
			<#=t.Name.AsField()#>Aggregate = <#=t.Name.AsLocal()#>Aggregate;
<#
    }
#>
		}
<#
		//    ____________
		//___/ Validate() \____________________________________
#>
		public ValidationResult Validate(Delete<#=_type.Name#>Command command)
		{
			<#=_type.Name#>Row row;
			if (!<#=_type.Name.AsField()#>Aggregate.ById.TryGetValue(command.Id, out row))
				return new ValidationResult("Did not find <#=_type.Name#> to be deleted: " + command.Id);
			if (row.RowVersion != command.RowVersion)
				return new ValidationResult($"Can't delete object v.{row.RowVersion} with command v.{command.RowVersion}");

<#
    foreach (var p in _type.DependsUpon
		.Where(x => x.OnDelete == DeleteReaction.Deny))
    {
		if (p.Property.DeclaringType == null)
			throw new Exception("p.Property.DeclaringType != null");
        var aggregate = $"{p.Property.DeclaringType.Name.AsField()}Aggregate";
#>
			if (<#=aggregate#>.ById.Values
				.Any(p => p.<#=p.Name#> == command.Id))
				return new ValidationResult(
					$"Can not delete <#=_type.Name#> {command.Id} " +
					$"because other objects depend on it: {<#=aggregate#>.ById.Values.Where(p => p.<#=p.Name#> == command.Id).Join(p => p.Id)}");
<#
    }
#>
			return ValidationResult.Success;
		}
    }
}

<#+
    private readonly MetaType _type;
#>